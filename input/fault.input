/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright 
 * information, see COPYRIGHT and COPYING.LESSER. 
 *
 * Copyright:     (c) 1997-2010 Lawrence Livermore National Security, LLC
 * Description:   Input file for example FAC Stokes solver 
 *
 ************************************************************************/
// This is the input file for the 2D FAC example
// demonstrating changes in boundary conditions.
//
// Note that using constant refine prolongation
// lead to slower convergence.

Main {
    dim = 2
    // Base name for output files.
    base_name = "fault"
    // Whether to log all nodes in a parallel run.
    log_all_nodes = TRUE
    // Visualization writers to write files for.
    vis_writer = "Vizamrai", "VisIt"
}

Elastic {
    // The FACStokes class is the "user class" in this example.
    // It owns the solver and contains the code to set up the solver.
    // The inputs for FACStokes is simply the inputs for the individual
    // parts owned by the FACStokes class.
    adaption_threshold = 1.0e-3
    min_full_refinement_level = 10

    lambda_ijk= 2, 2
    lambda_coord_min= -10.001, -10.001
    lambda_coord_max= 10.001, 10.001
    lambda_data= 
    1, 1,
    1, 1

    mu_ijk= 3, 3
    mu_coord_min= -10.001, -10.001
    mu_coord_max= 10.001, 10.001
    mu_data= 1, 1, 1,
    1, 1, 1,
    1, 1, 1

    v_rhs_ijk= 11, 11
    v_rhs_coord_min= -10.001, -10.001
    v_rhs_coord_max= 10.001, 10.001
    // v_rhs_data= 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1.03, 1.03, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1.03, 1.03, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1

    v_rhs_data= 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    fac_solver {
        // This is the input for the cell-centered Stokes FAC solver
        // class in the SAMRAI library.
        enable_logging = TRUE   // Bool flag to switch logging on/off
        max_cycles = 100         // Max number of FAC cycles to use
        residual_tol = 1e-3     // Residual tolerance to solve for
        num_pre_sweeps = 2      // Number of presmoothing sweeps to use
        num_post_sweeps = 2     // Number of postsmoothing sweeps to use
        smoothing_choice = "Tackley"
        coarse_solver_choice = "Tackley"
        coarse_solver_max_iterations = 32
        coarse_solver_tolerance = 1e-5
        v_prolongation_method = "V_REFINE"
    }
    boundary_conditions {
        dirichlet_vx_x_upper="4*y*y"
        dirichlet_vx_x_lower="0"
        dirichlet_vy_y_upper="0"
        dirichlet_vy_y_lower="0"
        neumann_vx_y_upper="0"
        neumann_vx_y_lower="0"
        neumann_vy_x_upper="0"
        neumann_vy_x_lower="0"
    }
}

CartesianGridGeometry {
    //  Specify lower/upper corners of the computational domain and a
    //  set of non-overlapping boxes defining domain interior.  If union 
    //  of boxes is not a parallelpiped, lower/upper corner data corresponds 
    //  to min/max corner indices over all boxes given.
    //  x_lo  -- (double array) lower corner of computational domain [REQD]
    //  x_up  -- (double array) upper corner of computational domain [REQD]
    //  domain_boxes  -- (box array) set of boxes that define interior of 
    //                   physical domain. [REQD]
    //  periodic_dimension -- (int array) coordinate directions in which 
    //                        domain is periodic.  Zero indicates not
    //                        periodic, non-zero value indicates periodicity.
    //                        [0]
    // domain_boxes = [(0,0), (127,127)]
    // domain_boxes = [(0,0), (63,63)]
    // domain_boxes = [(0,0), (31,31)]
    // domain_boxes = [(0,0), (15,15)]
    // domain_boxes = [(0,0), (7,7)]
    domain_boxes = [(0,0), (3,3)]
    x_lo         = -.5, -.5
    x_up         = .5, .5
    // x_lo         = -4, -4
    // x_up         = 4, 4
}

StandardTagAndInitialize {
    tagging_method = "GRADIENT_DETECTOR"
}

PatchHierarchy {
    // Information used to create patches in AMR hierarchy.
    // max_levels -- (int) max number of mesh levels in hierarchy [REQD]
    // 
    // For most of the following parameters, the number of precribed data
    // values need not match the number of levels in the hierarchy 
    // (determined by max_levels).  If more values are given than number 
    // of levels, extraneous values will be ignored.  If less are give, then
    // values that correspond to individual levels will apply to those 
    // levels.  Missing values will be taken from those for the finest
    // level specified.
    //
    // ratio_to_coarser {
    //   level_1 -- (int array) ratio between index spaces on 
    //              level 1 to level 0 [REQD]
    //   level_2 -- (int array)  ratio between index spaces on 
    //              level 2 to level 1 [REQD]
    //   etc....
    // }
    // largest_patch_size {
    //   level_0 -- (int array) largest patch allowed on level 0. 
    //              [REQD]    
    //   level_1 -- (int array)    "       "      "   "  level 1 
    //              [level 0 entry]
    //   etc....                       
    // }
    max_levels = 7
    proper_nesting_buffer = 2, 2, 2, 2, 2, 2, 2
    ratio_to_coarser {
        level_1            = 2, 2
        level_2            = 2, 2
        level_3            = 2, 2
        level_4            = 2, 2
        level_5            = 2, 2
        level_6            = 2, 2
        level_7            = 2, 2
    }
    largest_patch_size {
        // level_0 = 32, 32
        // level_0 = 8, 8
        level_0 = -1, -1
        // all finer levels will use same values as level_0...
    }
}

GriddingAlgorithm {
    enforce_proper_nesting = TRUE
    extend_to_domain_boundary = FALSE
    proper_nesting_buffer = 2, 2, 2, 2, 2, 2, 2
    // load_balance = FALSE
    efficiency_tolerance = 0.80
    combine_efficiency = 0.75
    // write_regrid_boxes = TRUE
    // read_regrid_boxes = TRUE
    // regrid_boxes_filename = "grid"
    check_nonrefined_tags = "ERROR"
    check_overlapping_patches = "ERROR"
    extend_tags_to_bdry = TRUE
    sequentialize_patch_indices = TRUE
    barrier_before_regrid = TRUE
    barrier_before_find_refinement = TRUE
    barrier_before_cluster = TRUE
    barrier_before_nest = TRUE
    barrier_before_limit = TRUE
    barrier_before_extend = TRUE
    barrier_before_balance = TRUE
    barrier_after_find_refinement = TRUE
    coalesce_boxes = FALSE
}
